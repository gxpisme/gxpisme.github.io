# CPU 高速缓存

## 计算机结构
先来看一台计算机的结构，其中最重要的就是CPU和主存储器（内存）。

还有一些附属的设备：磁盘、鼠标、键盘、显示器。

![image.png](/image/cpu_cache_1.png)


CPU是用来计算的，但是数据存放在**主存储器（内存）**中。

CPU运行的速度很快，但是从内存获取数据则特别慢。例如有如下代码

```java
a = 2;
b = 3;
a + b;
```

要计算a+b=？，a和b的值都放在主存储器（内存）中，

从主存储器（内存）获取a和b的值比较慢，但是CPU计算a+b会非常快，差异在100倍左右。

为了更好的利用CPU，减少这种速度差异，引入了高速缓存。(其实最开始两者是差不多的，后来随着各自的发展，两者的速度差异越来越大)

## CPU 高速缓存

![image.png](/image/cpu_cache_2.png)

高速缓存主要分为L1、L2、L3，用来解决寄存器与主存储器（内存）速度差异。

看下面这个图越向上，速度也快，造价越高；图越向下，速度越慢，造价越低。

![image.png](/image/cpu_cache_3.png)


他们的速度差异大概是如下

| 从CPU到设备 | CPU周期 | 时间 | 说明 |
| --- | --- | --- | --- |
| 寄存器 | 1 |  |  |
| L1 Cache | ~3-4 | ~0.5-1 ns | 价格高，与CPU最紧密，容量最小。分为一级数据缓存和一级指令缓存，一般大小为64k |
| L2 Cache | ~10-20 | ~3-7 ns | 第二层高速缓存，分为内部和外部两种芯片，容量一般在4M左右 |
| L3 Cache | ~40-45 | ~15 ns | 部分CPU具备，跨多核，成本在高速缓存里是最低的。 |
| 主存储器（内存） | ~120-240 | ~60-120 ns |  |


在多核CPU下，L1、L2、L3是如何分配的？一个核中有自己的L1、L2，多核共享L3。

![image.png](/image/cpu_cache_4.png)


## 缓存一致性

看如下的架构图，第一个CPU更新Cache，然后写入主内存，将其他Cache置为无效，其他Cache重新从主内存中获取最新数据。

![image.png](/image/cpu_cache_5.png)


在缓存的时候，缓存的最小单位是64byte数据，称为一个**缓存行**。缓存的单位是一个缓存行，假设用到4byte的数据，其实会把包含这4byte数据的64byte大小的数据缓存起来。


有缓存的地方，就会有数据不一致的情况。缓存一致性协议常见的有MESI，下面主要来说说MESI。

```
MESI 是四种状态，也就是**缓存行**的四种状态。

M：Modified   本CPU的该**缓存行**已经被修改，但是还没有写入到主内存中。
E：Exclusive  本CPU的该**缓存行**与主内存中的数据一致。
S：Share      多个CPU有**缓存行**与主内存中的数据一致。
I：Invalid    本CPU的该**缓存行**失效。
```

读

case1：现在CPU要读取数据，如果缓存行状态**是Invalid**，则直接从**主内存中**获取数据。

case2：现在CPU要读取数据，如果缓存行状态**不是Invalid**，则直接从**缓存中**获取数据。

写

case1：现在CPU要写数据，如果缓存行是Modified或者Exclusive，将数据写入到主内存中。

case2：现在CPU要写数据，如果缓存行是Share或者Invalid，会通知其他CPU缓存无效，写入主内存后，将缓存状态改为Modified。

参考资料

《深入理解计算机系统》

